# MZSA GEM – Инструкции для Copilot

**ВАЖНО: ВСЕГДА ОТВЕЧАЙ НА РУССКОМ ЯЗЫКЕ.**

## Обзор архитектуры
- Монорепозиторий содержит три активных компонента: `frontend/` (React + Vite), `backend/` (Express + Sequelize + SQLite) и `scraper/` (Python) с общей документацией в `docs/` — изменения обычно затрагивают несколько слоев.
- Фронтенд инициализируется через `src/main.tsx`, где `db.initializeData` заполняет LocalStorage перед рендерингом React; это гарантирует соответствие каталога данным из `src/data/**/*`.
- Админ-панель (`src/admin`) встроена, но маршрутизируется через `/admin` и использует тот же провайдер данных, что и публичное приложение, поэтому изменения мгновенно отражаются в обоих интерфейсах.
- Бэкенд предоставляет REST-ресурсы по адресу `http://localhost:3001/{trailers,accessories,orders,customers,settings}` и сохраняет данные в `backend/database.sqlite`, заполняемую через сиды из `db.json`.

## Рабочие процессы запуска и проверки
- Фронтенд: `cd frontend && npm install && npm run dev` (Vite на :5173). Сборка через `npm run build`; сначала выполняется проверка типов через `tsc -b`.
- Бэкенд: `cd backend && npm install && npm run seed && npm start` для пересоздания SQLite и запуска Express на :3001.
- Скрапер: `cd scraper && pip install -r requirements.txt && python scraper.py`; результаты сохраняются в `output/` по слагам прицепов.
- Быстрые проверки: `node check_db.js` для проверки количества записей в SQLite и использование DevTools браузера для подтверждения соответствия ключей `localStorage` (`onr_*`) изменениям данных.

## Жизненный цикл данных и синхронизация
- Основным источником данных является **REST API** (`backend/db.json` -> SQLite). Файлы в `frontend/src/data/` используются для инициализации, но при работе в режиме `DATA_SOURCE='rest'` данные берутся с бэкенда.
- Для сквозного распространения данных скрапера: запустите `scripts/transform_scraper_to_db.cjs` → обновите `backend/db.json` + скопируйте изображения в `frontend/public/images/**` → `npm run seed` в бэкенде для пересборки SQLite.
- При изменении данных (например, характеристик прицепов) убедитесь, что они обновлены и в `frontend/src/data/trailers.ts` (для консистентности), и в `backend/db.json`.
- `generate_catalog.py` — альтернативный экспортер, который перезаписывает те же файлы данных TypeScript напрямую из `output/`; он также очищает папки публичных изображений, поэтому коммитьте регенерированные ассеты осознанно.
- Метаданные складов, теги совместимости и правила выравнивания спецификаций закодированы в скрипте-трансформере — расширяйте эти хелперы (например, `parseDimensionsMM`, `inferAccessoryCategory`) вместо добавления ad-hoc конверсий в других местах.

## Соглашения фронтенда
- Общие типы находятся в `src/types/index.ts`; держите их авторитетными — React-компоненты, мок-данные и формы админки импортируют всё отсюда, поэтому расхождения схемы сразу видны при `tsc -b`.
- Доступ к данным осуществляется исключительно через `db` (либо `LocalStorageProvider`, либо `RestProvider`); если добавляете новую сущность, расширьте `IDatabaseProvider`, оба провайдера и `src/admin/dataProvider.ts` перед подключением UI.
- Фильтры каталога (`pages/Catalog.tsx`) зеркалируют параметры URL — сохраняйте хелперы парсинга/обновления при добавлении критериев, чтобы сохранить функциональность deep-linking.
- Конфигуратор (`pages/Configurator.tsx`) управляет многошаговым мастером; он определяет совместимые прицепы через мемоизированные предикаты по полям `trailer.compatibility` и `maxVehicle*`, поэтому добавляйте новые правила подбора там, а не разбрасывайте логику.

## Специфика админки и авторизации
- Ресурсы React Admin находятся в `src/admin/resources/**`; экраны списков/редактирования/создания — это тонкие обертки вокруг вызовов `db`, поэтому серверные валидации должны дублироваться на клиенте.
- `authProvider` основан на LocalStorage с фиксированными учетными данными (`admin/admin123`, `manager/manager123`); настройте это перед внедрением реальной бэкенд-авторизации, чтобы не заблокировать себе доступ.
- Настройки рассматриваются как синглтон: `dataProvider` оборачивает их в массив с `id: 'default'`; сохраняйте эту структуру, если вводите мульти-тенантные конфиги, чтобы не сломать ожидания React Admin.

## Паттерны бэкенда
- `backend/server.js` использует `createCrud` для регистрации REST-эндпоинтов; расширение моделей (например, добавление `/settings`) обычно означает настройку этого хелпера, а не дублирование обработчиков.
- Поиск прицепов реализует эвристику на естественном языке (ключевые слова категорий, парсинг длины) с использованием `Op` из Sequelize и кастомных `where` условий — расширяйте этот блок для более умных фильтров, сохраняя фоллбэк логику `{ name/model LIKE %q% }`.
- Модели Sequelize в `backend/models/*.js` намеренно денормализуют JSON-поля (`features`, `images`, `compatibility`, `specs`); предпочитайте JSON-колонки для гибких спецификаций созданию вспомогательных таблиц.
- При сидинге `backend/seed.js` выравнивает устаревшие поля `specs`; обновляйте маппинг там, когда вводите новые скалярные колонки, чтобы сохранить совместимость с `db.json`.

## Инструментарий и ссылки
- Справочная документация домена находится в `docs/ARCHITECTURE.md`, `DATA_MODELS.md` и `USER_GUIDE.md`; ссылайтесь на них в описаниях PR при изменении сквозных потоков.
- `scripts/import_from_1c_stub.ts` — заглушка для импорта CSV из 1С — соблюдайте её CLI-контракт (`npm run import:1c -- --file=... --output=...`), если начнете реальную реализацию.
- Ассеты изображений находятся в `frontend/public/images/{trailers,accessories}`; скрипты-генераторы очищают эти папки, поэтому держите оригиналы под контролем версий или делайте бэкапы перед регенерацией.
- При отладке несоответствий данных сравнивайте `scraper/output/<segment>/<slug>/<slug>.json`, `backend/db.json` и пейлоады LocalStorage в этом порядке, чтобы определить, на каком этапе произошло расхождение.
